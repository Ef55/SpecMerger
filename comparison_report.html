
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Comparison Report</title>
            <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; }
                .section { margin-bottom: 20px; }
                .case { margin-left: 20px; }
                .error { color: red; }
                .success { color: green; }
            </style>
        </head>
        <body>
            <h1>Comparison Report</h1>
            
            <h2>Correct Matches</h2>
            <div class='success'><p><h3>22.2.2 Pattern Semantics:</h3></p></div><div class='success'><p><h3>22.2.2.6 Runtime Semantics: CompileQuantifierPrefix:</h3></p></div><div class='success'><p><h3>22.2.2.5 Runtime Semantics: CompileQuantifier:</h3></p></div><div class='success'><p><h3>22.2.2.7.1 CharacterSetMatcher ( rer, A, invert, direction ):</h3></p></div><div class='success'><p><h3>22.2.2.7.2 BackreferenceMatcher ( rer, n, direction ):</h3></p></div><div class='success'><p><h3>22.2.2.9.1 CharacterRange ( A, B ):</h3></p></div><div class='success'><p><h3>22.2.2.9.2 WordCharacters ( rer ):</h3></p></div><div class='success'><p><h3>22.2.2.9 Runtime Semantics: CompileToCharSet:</h3></p></div><div class='success'><p><h3>22.2.2.8 Runtime Semantics: CompileCharacterClass:</h3></p></div><div class='success'><p><h3>22.2.2.4.1 IsWordChar ( rer, Input, e ):</h3></p></div><div class='success'><p><h3>22.2.2.3.1 RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount ):</h3></p></div><div class='success'><p><h3>22.2.2.3 Runtime Semantics: CompileSubpattern:</h3></p></div><div class='success'><p><h3>22.2.2.4 Runtime Semantics: CompileAssertion:</h3></p></div><div class='success'><p><h3>22.2.2.7 Runtime Semantics: CompileAtom:</h3></p></div><div class='success'><p><h3>22.2.2.2 Runtime Semantics: CompilePattern:</h3></p></div><div class='success'><p><h3>22.2.7.3 AdvanceStringIndex ( S, index, unicode ):</h3></p></div><div class='success'><p><h3>22.2.7.4 GetStringIndex ( S, codePointIndex ):</h3></p></div><div class='success'><p><h3>22.2.8 Properties of RegExp Instances:</h3></p></div><div class='success'><p><h3>22.2.8.1 lastIndex:</h3></p></div><div class='success'><p><h3>22.2.9 RegExp String Iterator Objects:</h3></p></div><div class='success'><p><h3>22.2.3.3 RegExpInitialize ( obj, pattern, flags ):</h3></p></div><div class='success'><p><h3>22.2.7.7 GetMatchIndexPair ( S, match ):</h3></p></div><div class='success'><p><h3>22.2.7.6 GetMatchString ( S, match ):</h3></p></div><div class='success'><p><h3>22.2.7.1 RegExpExec ( R, S ):</h3></p></div><div class='success'><p><h3>22.2.6.8 RegExp.prototype [ @@match ] ( string ):</h3></p></div><div class='success'><p><h3>22.2.6.12 RegExp.prototype [ @@search ] ( string ):</h3></p></div><div class='success'><p><h3>22.2.6.16 RegExp.prototype.test ( S ):</h3></p></div><div class='success'><p><h3>22.2.9.1 CreateRegExpStringIterator ( R, S, global, fullUnicode ):</h3></p></div><div class='success'><p><h3>22.2.1.8 Static Semantics: CapturingGroupName:</h3></p></div><div class='success'><p><h3>22.2.1.7 Static Semantics: GroupSpecifiersThatMatch ( thisGroupName ):</h3></p></div><div class='success'><p><h3>22.2.1.6 Static Semantics: CharacterValue:</h3></p></div><div class='success'><p><h3>22.2.1.5 Static Semantics: IsCharacterClass:</h3></p></div><div class='success'><p><h3>22.2.1.4 Static Semantics: CapturingGroupNumber:</h3></p></div><div class='success'><p><h3>22.2.1.2 Static Semantics: CountLeftCapturingParensWithin ( node ):</h3></p></div><div class='success'><p><h3>22.2.1.3 Static Semantics: CountLeftCapturingParensBefore ( node ):</h3></p></div><div class='success'><p><h3>22.2.1.1 Static Semantics: Early Errors:</h3></p></div>
            
            <h2>Sections Not Found</h2>
            <div class='error'><p><h3>IN COQ:</h3> </p></div><br><div class='error'><p><h3>IN ECMAScript:</h3> 22.2 RegExp (Regular Expression) Objects : <a href='https://262.ecma-international.org/14.0/#sec-regexp-regular-expression-objects'>https://262.ecma-international.org/14.0/#sec-regexp-regular-expression-objects</a><br><br>22.2.1.9 Static Semantics: RegExpIdentifierCodePoints : <a href='https://262.ecma-international.org/14.0/#sec-regexpidentifiercodepoints'>https://262.ecma-international.org/14.0/#sec-regexpidentifiercodepoints</a><br><br>22.2.1.10 Static Semantics: RegExpIdentifierCodePoint : <a href='https://262.ecma-international.org/14.0/#sec-regexpidentifiercodepoint'>https://262.ecma-international.org/14.0/#sec-regexpidentifiercodepoint</a><br><br>22.2.2.7.3 Canonicalize ( rer, ch ) : <a href='https://262.ecma-international.org/14.0/#sec-runtime-semantics-canonicalize-ch'>https://262.ecma-international.org/14.0/#sec-runtime-semantics-canonicalize-ch</a><br><br>22.2.2.9.3 UnicodeMatchProperty ( p ) : <a href='https://262.ecma-international.org/14.0/#sec-runtime-semantics-unicodematchproperty-p'>https://262.ecma-international.org/14.0/#sec-runtime-semantics-unicodematchproperty-p</a><br><br>22.2.2.9.4 UnicodeMatchPropertyValue ( p, v ) : <a href='https://262.ecma-international.org/14.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'>https://262.ecma-international.org/14.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v</a><br><br>22.2.3 Abstract Operations for RegExp Creation : <a href='https://262.ecma-international.org/14.0/#sec-abstract-operations-for-regexp-creation'>https://262.ecma-international.org/14.0/#sec-abstract-operations-for-regexp-creation</a><br><br>22.2.3.1 RegExpCreate ( P, F ) : <a href='https://262.ecma-international.org/14.0/#sec-regexpcreate'>https://262.ecma-international.org/14.0/#sec-regexpcreate</a><br><br>22.2.3.2 RegExpAlloc ( newTarget ) : <a href='https://262.ecma-international.org/14.0/#sec-regexpalloc'>https://262.ecma-international.org/14.0/#sec-regexpalloc</a><br><br>22.2.3.4 Static Semantics: ParsePattern ( patternText, u ) : <a href='https://262.ecma-international.org/14.0/#sec-parsepattern'>https://262.ecma-international.org/14.0/#sec-parsepattern</a><br><br>22.2.4 The RegExp Constructor : <a href='https://262.ecma-international.org/14.0/#sec-regexp-constructor'>https://262.ecma-international.org/14.0/#sec-regexp-constructor</a><br><br>22.2.4.1 RegExp ( pattern, flags ) : <a href='https://262.ecma-international.org/14.0/#sec-regexp-pattern-flags'>https://262.ecma-international.org/14.0/#sec-regexp-pattern-flags</a><br><br>22.2.5 Properties of the RegExp Constructor : <a href='https://262.ecma-international.org/14.0/#sec-properties-of-the-regexp-constructor'>https://262.ecma-international.org/14.0/#sec-properties-of-the-regexp-constructor</a><br><br>22.2.5.1 RegExp.prototype : <a href='https://262.ecma-international.org/14.0/#sec-regexp.prototype'>https://262.ecma-international.org/14.0/#sec-regexp.prototype</a><br><br>22.2.5.2 get RegExp [ @@species ] : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp-@@species'>https://262.ecma-international.org/14.0/#sec-get-regexp-@@species</a><br><br>22.2.6 Properties of the RegExp Prototype Object : <a href='https://262.ecma-international.org/14.0/#sec-properties-of-the-regexp-prototype-object'>https://262.ecma-international.org/14.0/#sec-properties-of-the-regexp-prototype-object</a><br><br>22.2.6.1 RegExp.prototype.constructor : <a href='https://262.ecma-international.org/14.0/#sec-regexp.prototype.constructor'>https://262.ecma-international.org/14.0/#sec-regexp.prototype.constructor</a><br><br>22.2.6.2 RegExp.prototype.exec ( string ) : <a href='https://262.ecma-international.org/14.0/#sec-regexp.prototype.exec'>https://262.ecma-international.org/14.0/#sec-regexp.prototype.exec</a><br><br>22.2.6.3 get RegExp.prototype.dotAll : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.dotAll'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.dotAll</a><br><br>22.2.6.4 get RegExp.prototype.flags : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.flags'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.flags</a><br><br>22.2.6.4.1 RegExpHasFlag ( R, codeUnit ) : <a href='https://262.ecma-international.org/14.0/#sec-regexphasflag'>https://262.ecma-international.org/14.0/#sec-regexphasflag</a><br><br>22.2.6.5 get RegExp.prototype.global : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.global'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.global</a><br><br>22.2.6.6 get RegExp.prototype.hasIndices : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.hasIndices'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.hasIndices</a><br><br>22.2.6.7 get RegExp.prototype.ignoreCase : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.ignorecase'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.ignorecase</a><br><br>22.2.6.10 get RegExp.prototype.multiline : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.multiline'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.multiline</a><br><br>22.2.6.11 RegExp.prototype [ @@replace ] ( string, replaceValue ) : <a href='https://262.ecma-international.org/14.0/#sec-regexp.prototype-@@replace'>https://262.ecma-international.org/14.0/#sec-regexp.prototype-@@replace</a><br><br>22.2.6.13 get RegExp.prototype.source : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.source'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.source</a><br><br>22.2.6.13.1 EscapeRegExpPattern ( P, F ) : <a href='https://262.ecma-international.org/14.0/#sec-escaperegexppattern'>https://262.ecma-international.org/14.0/#sec-escaperegexppattern</a><br><br>22.2.6.14 RegExp.prototype [ @@split ] ( string, limit ) : <a href='https://262.ecma-international.org/14.0/#sec-regexp.prototype-@@split'>https://262.ecma-international.org/14.0/#sec-regexp.prototype-@@split</a><br><br>22.2.6.15 get RegExp.prototype.sticky : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.sticky'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.sticky</a><br><br>22.2.6.17 RegExp.prototype.toString ( ) : <a href='https://262.ecma-international.org/14.0/#sec-regexp.prototype.tostring'>https://262.ecma-international.org/14.0/#sec-regexp.prototype.tostring</a><br><br>22.2.6.18 get RegExp.prototype.unicode : <a href='https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.unicode'>https://262.ecma-international.org/14.0/#sec-get-regexp.prototype.unicode</a><br><br>22.2.7 Abstract Operations for RegExp Matching : <a href='https://262.ecma-international.org/14.0/#sec-abstract-operations-for-regexp-matching'>https://262.ecma-international.org/14.0/#sec-abstract-operations-for-regexp-matching</a><br><br>22.2.9.2 The %RegExpStringIteratorPrototype% Object : <a href='https://262.ecma-international.org/14.0/#sec-%regexpstringiteratorprototype%-object'>https://262.ecma-international.org/14.0/#sec-%regexpstringiteratorprototype%-object</a><br><br>22.2.9.2.1 %RegExpStringIteratorPrototype%.next ( ) : <a href='https://262.ecma-international.org/14.0/#sec-%regexpstringiteratorprototype%.next'>https://262.ecma-international.org/14.0/#sec-%regexpstringiteratorprototype%.next</a><br><br>22.2.9.2.2 %RegExpStringIteratorPrototype% [ @@toStringTag ] : <a href='https://262.ecma-international.org/14.0/#sec-%regexpstringiteratorprototype%-@@tostringtag'>https://262.ecma-international.org/14.0/#sec-%regexpstringiteratorprototype%-@@tostringtag</a></p></div>

            <h2>Sections with Different Titles</h2>
            Empty

            <h2>Sections with Different Descriptions</h2>
            <div class='error'><p><h3>IN COQ:</h3> <div class='section'><h3>22.2.2.1.1 RegExp Records, <a download href='file:///home/martin/regex_coq/warblre/mechanization/spec/RegExpRecord.v'><b>RegExpRecord.v</b>: 2 - 19</a></h3><p>A RegExp Record is a Record value used to store information about a RegExp that is needed during compilation and possibly during matching. It has the following fields: [[IgnoreCase]] [[Multiline]] [[DotAll]] [[Unicode]] [[CapturingGroupsCount]] </p></div></p><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.2.1.1 RegExp Records, <a href='https://262.ecma-international.org/14.0/#sec-regexp-records'>https://262.ecma-international.org/14.0/#sec-regexp-records</a></h3><p>A RegExp Record is a Record value used to store information about a RegExp that is needed during compilation and possibly during matching. It has the following fields: </p></div></p></div><br><br><div class='error'><p><h3>IN COQ:</h3> <div class='section'><h3>22.2.2.1 Notation, <a download href='file:///home/martin/regex_coq/warblre/mechanization/spec/Notation.v'><b>Notation.v</b>: 3 - 73</a>, <a download href='file:///home/martin/regex_coq/warblre/mechanization/spec/Parameters.v'><b>Parameters.v</b>: 44 - 44</a></h3><p>The descriptions below use the following internal data structures: A CaptureRange is an ordered pair (startIndex, endIndex) that represents the range of characters included in a capture, where startIndex is an integer representing the start index (inclusive) of the range within Input, and endIndex is an integer representing the end index (exclusive) of the range within Input. For any CaptureRange, these indices must satisfy the invariant that startIndex ≤ endIndex. A MatchState is an ordered triple (input, endIndex, captures) where input is a List of characters representing the String being matched, endIndex is an integer, and captures is a List of values, one for each left-capturing parenthesis in the pattern. States are used to represent partial match states in the regular expression matching algorithms. The endIndex is one plus the index of the last input character matched so far by the pattern, while captures holds the results of capturing parentheses. The nth element of captures is either a CaptureRange representing the range of characters captured by the nth set of capturing parentheses, or undefined if the nth set of capturing parentheses hasn&#x27;t been reached yet. Due to backtracking, many States may be in use at any time during the matching process. A MatchResult is either a MatchState or the special token failure that indicates that the match failed. A MatcherContinuation is an Abstract Closure that takes one MatchState argument and returns a MatchResult result. The MatcherContinuation attempts to match the remaining portion (specified by the closure&#x27;s captured values) of the pattern against Input, starting at the intermediate state given by its MatchState argument. If the match succeeds, the MatcherContinuation returns the final MatchState that it reached; if the match fails, the MatcherContinuation returns failure. A Matcher is an Abstract Closure that takes two arguments—a MatchState and a MatcherContinuation—and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by the closure&#x27;s captured values) of the pattern against the MatchState&#x27;s input, starting at the intermediate state given by its MatchState argument. The MatcherContinuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new MatchState, the Matcher then calls MatcherContinuation on that new MatchState to test if the rest of the pattern can match as well. If it can, the Matcher returns the MatchState returned by MatcherContinuation; if not, the Matcher may try different choices at its choice points, repeatedly calling MatcherContinuation until it either succeeds or all possibilities have been exhausted. 
[...] A CharSet is a mathematical set of characters. In the context of a Unicode pattern, “all characters” means the CharSet containing all code point values; otherwise “all characters” means the CharSet containing all code unit values. [...] </p></div></p><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.2.1 Notation, <a href='https://262.ecma-international.org/14.0/#sec-pattern-notation'>https://262.ecma-international.org/14.0/#sec-pattern-notation</a></h3><p>The descriptions below use the following internal data structures:  A CharSet is a mathematical set of characters. In the context of a Unicode pattern, “all characters” means the CharSet containing all code point values; otherwise “all characters” means the CharSet containing all code unit values.
 A CaptureRange is an ordered pair (startIndex, endIndex) that represents the range of characters included in a capture, where startIndex is an integer representing the start index (inclusive) of the range within Input, and endIndex is an integer representing the end index (exclusive) of the range within Input. For any CaptureRange, these indices must satisfy the invariant that startIndex ≤ endIndex.
 A MatchState is an ordered triple (input, endIndex, captures) where input is a List of characters representing the String being matched, endIndex is an integer, and captures is a List of values, one for each left-capturing parenthesis in the pattern. States are used to represent partial match states in the regular expression matching algorithms. The endIndex is one plus the index of the last input character matched so far by the pattern, while captures holds the results of capturing parentheses. The n^th element of captures is either a CaptureRange representing the range of characters captured by the n^th set of capturing parentheses, or undefined if the n^th set of capturing parentheses hasn&#x27;t been reached yet. Due to backtracking, many States may be in use at any time during the matching process.
 A MatchResult is either a MatchState or the special token failure that indicates that the match failed.
 A MatcherContinuation is an Abstract Closure that takes one MatchState argument and returns a MatchResult result. The MatcherContinuation attempts to match the remaining portion (specified by the closure&#x27;s captured values) of the pattern against Input, starting at the intermediate state given by its MatchState argument. If the match succeeds, the MatcherContinuation returns the final MatchState that it reached; if the match fails, the MatcherContinuation returns failure.
 A Matcher is an Abstract Closure that takes two arguments—a MatchState and a MatcherContinuation—and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by the closure&#x27;s captured values) of the pattern against the MatchState&#x27;s input, starting at the intermediate state given by its MatchState argument. The MatcherContinuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new MatchState, the Matcher then calls MatcherContinuation on that new MatchState to test if the rest of the pattern can match as well. If it can, the Matcher returns the MatchState returned by MatcherContinuation; if not, the Matcher may try different choices at its choice points, repeatedly calling MatcherContinuation until it either succeeds or all possibilities have been exhausted.
</p></div></p></div><br><br><div class='error'><p><h3>IN COQ:</h3> <div class='section'><h3>22.2.7.5 Match Records, <a download href='file:///home/martin/regex_coq/warblre/mechanization/spec/Frontend.v'><b>Frontend.v</b>: 132 - 142</a></h3><p>A Match Record is a Record value used to encapsulate the start and end indices of a regular expression match or capture. Match Records have the fields listed in Table 67. [[StartIndex]] 	a non-negative integer [[EndIndex]] 	an integer ≥ [[StartIndex]] </p></div></p><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.7.5 Match Records, <a href='https://262.ecma-international.org/14.0/#sec-match-records'>https://262.ecma-international.org/14.0/#sec-match-records</a></h3><p>A Match Record is a Record value used to encapsulate the start and end indices of a regular expression match or capture. Match Records have the fields listed in Table 67. </p></div></p></div>

            <h2>Cases Not Found At All</h2>
            <div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.1 Static Semantics: Early Errors, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors</a></h3><p></p></div></p><p><h3>Case not found:</h3> <div class='case'><p>UnicodePropertyValueExpression ::  UnicodePropertyName = UnicodePropertyValue</p><pre>* It is a Syntax Error if the source text matched by UnicodePropertyName is not a Unicode property name or property alias listed in the “Property name and aliases” column of Table 65.
* It is a Syntax Error if the source text matched by UnicodePropertyValue is not a property value or property value alias for the Unicode property or property alias given by the source text matched by UnicodePropertyName listed in PropertyValueAliases.txt.
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.1 Static Semantics: Early Errors, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors</a></h3><p></p></div></p><p><h3>Case not found:</h3> <div class='case'><p>RegExpIdentifierPart ::  \ RegExpUnicodeEscapeSequence</p><pre>* It is a Syntax Error if the CharacterValue of RegExpUnicodeEscapeSequence is not the numeric value of some code point matched by the IdentifierPartChar lexical grammar production.
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.1 Static Semantics: Early Errors, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors</a></h3><p></p></div></p><p><h3>Case not found:</h3> <div class='case'><p>RegExpIdentifierStart ::  \ RegExpUnicodeEscapeSequence</p><pre>* It is a Syntax Error if the CharacterValue of RegExpUnicodeEscapeSequence is not the numeric value of some code point matched by the IdentifierStartChar lexical grammar production.
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.1 Static Semantics: Early Errors, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors</a></h3><p></p></div></p><p><h3>Case not found:</h3> <div class='case'><p>RegExpIdentifierStart ::  UnicodeLeadSurrogate UnicodeTrailSurrogate</p><pre>* It is a Syntax Error if RegExpIdentifierCodePoint of RegExpIdentifierStart is not matched by the UnicodeIDStart lexical grammar production.
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.1 Static Semantics: Early Errors, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors</a></h3><p></p></div></p><p><h3>Case not found:</h3> <div class='case'><p>UnicodePropertyValueExpression ::  LoneUnicodePropertyNameOrValue</p><pre>* It is a Syntax Error if the source text matched by LoneUnicodePropertyNameOrValue is not a Unicode property value or property value alias for the General_Category (gc) property listed in PropertyValueAliases.txt, nor a binary property or binary property alias listed in the “Property name and aliases” column of Table 66.
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.1 Static Semantics: Early Errors, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-early-errors</a></h3><p></p></div></p><p><h3>Case not found:</h3> <div class='case'><p>RegExpIdentifierPart ::  UnicodeLeadSurrogate UnicodeTrailSurrogate</p><pre>* It is a Syntax Error if RegExpIdentifierCodePoint of RegExpIdentifierPart is not matched by the UnicodeIDContinue lexical grammar production.
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.4 Static Semantics: CapturingGroupNumber, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-capturing-group-number'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-capturing-group-number</a></h3><p>The syntax-directed operation CapturingGroupNumber takes no arguments and returns a positive integer. It is defined piecewise over the following productions: </p></div></p><p><h3>Case not found:</h3> <div class='case'><p>DecimalEscape ::  NonZeroDigit</p><pre>1. Return the MV of NonZeroDigit.
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.4 Static Semantics: CapturingGroupNumber, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-capturing-group-number'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-capturing-group-number</a></h3><p>The syntax-directed operation CapturingGroupNumber takes no arguments and returns a positive integer. It is defined piecewise over the following productions: </p></div></p><p><h3>Case not found:</h3> <div class='case'><p>DecimalEscape ::  NonZeroDigit DecimalDigits</p><pre>1. Let n be the number of code points in DecimalDigits.
2. Return (the MV of NonZeroDigit × 10^n plus the MV of DecimalDigits).
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.1.6 Static Semantics: CharacterValue, <a href='https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-character-value'>https://262.ecma-international.org/14.0/#sec-patterns-static-semantics-character-value</a></h3><p>The syntax-directed operation CharacterValue takes no arguments and returns a non-negative integer. It is defined piecewise over the following productions: </p></div></p><p><h3>Case not found:</h3> <div class='case'><p>ClassAtom ::  -</p><pre>1. Return the numeric value of U+002D (HYPHEN-MINUS).
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.2.9 Runtime Semantics: CompileToCharSet, <a href='https://262.ecma-international.org/14.0/#sec-compiletocharset'>https://262.ecma-international.org/14.0/#sec-compiletocharset</a></h3><p>The syntax-directed operation CompileToCharSet takes argument rer (a RegExp Record) and returns a CharSet. It is defined piecewise over the following productions: </p></div></p><p><h3>Case not found:</h3> <div class='case'><p>ClassAtom ::  -</p><pre>1. Return the CharSet containing the single character - U+002D (HYPHEN-MINUS).
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.2.9 Runtime Semantics: CompileToCharSet, <a href='https://262.ecma-international.org/14.0/#sec-compiletocharset'>https://262.ecma-international.org/14.0/#sec-compiletocharset</a></h3><p>The syntax-directed operation CompileToCharSet takes argument rer (a RegExp Record) and returns a CharSet. It is defined piecewise over the following productions: </p></div></p><p><h3>Case not found:</h3> <div class='case'><p>UnicodePropertyValueExpression ::  UnicodePropertyName = UnicodePropertyValue</p><pre>1. Let ps be the source text matched by UnicodePropertyName.
2. Let p be UnicodeMatchProperty(ps).
3. Assert: p is a Unicode property name or property alias listed in the “Property name and aliases” column of Table 65.
4. Let vs be the source text matched by UnicodePropertyValue.
5. Let v be UnicodeMatchPropertyValue(p, vs).
6. Return the CharSet containing all Unicode code points whose character database definition includes the property p with value v.
</pre></div></p></div><br><br><div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.2.9 Runtime Semantics: CompileToCharSet, <a href='https://262.ecma-international.org/14.0/#sec-compiletocharset'>https://262.ecma-international.org/14.0/#sec-compiletocharset</a></h3><p>The syntax-directed operation CompileToCharSet takes argument rer (a RegExp Record) and returns a CharSet. It is defined piecewise over the following productions: </p></div></p><p><h3>Case not found:</h3> <div class='case'><p>UnicodePropertyValueExpression ::  LoneUnicodePropertyNameOrValue</p><pre>1. Let s be the source text matched by LoneUnicodePropertyNameOrValue.
2.IfUnicodeMatchPropertyValue(General_Category,s) is a Unicode property value or property value alias for the General_Category (gc) property listed inPropertyValueAliases.txt, then
a. Return the CharSet containing all Unicode code points whose character database definition includes the property “General_Category” with value s.
3. Let p be UnicodeMatchProperty(s).
4. Assert: p is a binary Unicode property or binary property alias listed in the “Property name and aliases” column of Table 66.
5. Return the CharSet containing all Unicode code points whose character database definition includes the property p with value “True”.
</pre></div></p></div>

            <h2>Cases with Right Side Not Found</h2>
            <div class='error'><p><h3>IN ECMAScript:</h3> <div class='section'><h3>22.2.2.7 Runtime Semantics: CompileAtom, <a href='https://262.ecma-international.org/14.0/#sec-compileatom'>https://262.ecma-international.org/14.0/#sec-compileatom</a></h3><p>The syntax-directed operation CompileAtom takes arguments rer (a RegExp Record) and direction (forward or backward) and returns a Matcher. It is defined piecewise over the following productions: </p></div></p><p><h3>Case:</h3> <div class='case'><p>Atom ::  (?: Disjunction )</p><pre>1. Return CompileSubpattern of Disjunction with arguments rer and direction.
</pre></div></p><p>Left cases found: <div class='case'><p>Atom ::  ( GroupSpecifier_opt Disjunction )</p><pre>1. Let m be CompileSubpattern of Disjunction with arguments rer and direction.
2. Let parenIndex be CountLeftCapturingParensBefore(Atom).
3. Return a new Matcher with parameters (x, c) that captures direction, m, and parenIndex and performs the following steps when called:
a. Assert: x is a MatchState.
b. Assert: c is a MatcherContinuation.
c. Let d be a new MatcherContinuation with parameters (y) that captures x, c, direction, and parenIndex and performs the following steps when called:
i. Assert: y is a MatchState.
ii. Let cap be a copy of y&#x27;s captures List.
iii. Let Input be x&#x27;s input.
iv. Let xe be x&#x27;s endIndex.
v. Let ye be y&#x27;s endIndex.
vi. If direction is forward, then
1. Assert: xe ≤ ye.
2. Let r be the CaptureRange (xe, ye).
vii. Else,
1. Assert: direction is backward.
2. Assert: ye ≤ xe.
3. Let r be the CaptureRange (ye, xe).
viii. Set cap[parenIndex + 1] to r.
ix. Let z be the MatchState (Input, ye, cap).
x. Return c(z).
d. Return m(x, d).
</pre></div>
<div class='case'><p>Atom ::  PatternCharacter</p><pre>1. Let ch be the character matched by PatternCharacter.
2. Let A be a one-element CharSet containing the character ch.
3. Return CharacterSetMatcher(rer, A, false, direction).
</pre></div>
<div class='case'><p>Atom ::  .</p><pre>1. Let A be the CharSet of all characters.
2. If rer.[[DotAll]] is not true, then
a. Remove from A all characters corresponding to a code point on the right-hand side of the LineTerminator production.
3. Return CharacterSetMatcher(rer, A, false, direction).
</pre></div>
<div class='case'><p>Atom ::  CharacterClass</p><pre>1. Let cc be CompileCharacterClass of CharacterClass with argument rer.
2. Return CharacterSetMatcher(rer, cc.[[CharSet]], cc.[[Invert]], direction).
</pre></div></p></div>

            <h2>Cases Found Multiple Times</h2>
            Empty

            <h2>Cases with Different Code</h2>
            <div class='error'><p><h3>Section:</h3> <div class='section'><h3>22.2.7.8 MakeMatchIndicesIndexPairArray ( S, indices, groupNames, hasGroups ), <a download href='file:///home/martin/regex_coq/warblre/mechanization/spec/Frontend.v'><b>Frontend.v</b>: 203 - 270</a></h3><p>The abstract operation MakeMatchIndicesIndexPairArray takes arguments S (a String), indices (a List of either Match Records or undefined), groupNames (a List of either Strings or undefined), and hasGroups (a Boolean) and returns an Array. It performs the following steps when called: </p></div></p><p><h3>IN COQ:</h3> <div class='case'><p> :: </p><pre>a. Let matchIndices be indices[i].
b. If matchIndices is not undefined, then
i. Let matchIndexPair be GetMatchIndexPair(S, matchIndices).
c. Else,
i. Let matchIndexPair be undefined
d. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(i)), matchIndexPair).
a. Let matchIndices be indices[i].
b. If matchIndices is not undefined, then
i. Let matchIndexPair be GetMatchIndexPair(S, matchIndices).
c. Else,
i. Let matchIndexPair be undefined
e. If i &gt; 0 and groupNames[i - 1] is not undefined, then
ii. Perform ! CreateDataPropertyOrThrow(groups, groupNames[i - 1], matchIndexPair).
1. Let n be the number of elements in indices.
2. Assert: n &lt; 2^32 - 1.
3. Assert: groupNames has n - 1 elements.
</pre></div></p><p><h3>IN ECMAScript</h3>: <div class='case'><p> :: </p><pre>1. Let n be the number of elements in indices.
2. Assert: n &lt; 2^32 - 1.
3. Assert: groupNames has n - 1 elements.
4. NOTE: The groupNames List contains elements aligned with the indices List starting at indices[1].
5. Let A be ! ArrayCreate(n).
6.IfhasGroupsistrue, then
a. Let groups be OrdinaryObjectCreate(null).
7.Else,
a. Let groups be undefined.
8. Perform ! CreateDataPropertyOrThrow(A, &quot;groups&quot;, groups).
9.For eachintegerisuch that 0 ≤i&lt;n, in ascending order, do
a. Let matchIndices be indices[i].
b.IfmatchIndicesis notundefined, then
i. Let matchIndexPair be GetMatchIndexPair(S, matchIndices).
c.Else,
i. Let matchIndexPair be undefined.
d. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(i)), matchIndexPair).
e.Ifi&gt; 0 andgroupNames[i- 1] is notundefined, then
i. Assert: groups is not undefined.
ii. Perform ! CreateDataPropertyOrThrow(groups, groupNames[i - 1], matchIndexPair).
10. Return A.
</pre></div></p></div><b>line-diffs</b> : --- 
<br>+++ 
<br>@@ -1,16 +1,21 @@
<br>+1.Letnbethenumberofelementsinindices.<br>+2.Assert:n<2^32-1.<br>+3.Assert:groupNameshasn-1elements.<br>+4.NOTE:ThegroupNamesListcontainselementsalignedwiththeindicesListstartingatindices[1].<br>+5.LetAbe!ArrayCreate(n).<br>+6.IfhasGroupsistrue,then<br>+a.LetgroupsbeOrdinaryObjectCreate(null).<br>+7.Else,<br>+a.Letgroupsbeundefined.<br>+8.Perform!CreateDataPropertyOrThrow(A,"groups",groups).<br>+9.Foreachintegerisuchthat0≤i<n,inascendingorder,do<br> a.LetmatchIndicesbeindices[i].<br> b.IfmatchIndicesisnotundefined,then<br> i.LetmatchIndexPairbeGetMatchIndexPair(S,matchIndices).<br> c.Else,<br>-i.LetmatchIndexPairbeundefined<br>+i.LetmatchIndexPairbeundefined.<br> d.Perform!CreateDataPropertyOrThrow(A,!ToString(𝔽(i)),matchIndexPair).<br>-a.LetmatchIndicesbeindices[i].<br>-b.IfmatchIndicesisnotundefined,then<br>-i.LetmatchIndexPairbeGetMatchIndexPair(S,matchIndices).<br>-c.Else,<br>-i.LetmatchIndexPairbeundefined<br> e.Ifi>0andgroupNames[i-1]isnotundefined,then<br>+i.Assert:groupsisnotundefined.<br> ii.Perform!CreateDataPropertyOrThrow(groups,groupNames[i-1],matchIndexPair).<br>-1.Letnbethenumberofelementsinindices.<br>-2.Assert:n<2^32-1.<br>-3.Assert:groupNameshasn-1elements.<br>+10.ReturnA.<br><br><div class='error'><p><h3>Section:</h3> <div class='section'><h3>22.2.7.2 RegExpBuiltinExec ( R, S ), <a download href='file:///home/martin/regex_coq/warblre/mechanization/spec/Frontend.v'><b>Frontend.v</b>: 296 - 554</a></h3><p>The abstract operation RegExpBuiltinExec takes arguments R (an initialized RegExp instance) and S (a String) and returns either a normal completion containing either an Array exotic object or null, or a throw completion. It performs the following steps when called: </p></div></p><p><h3>IN COQ:</h3> <div class='case'><p> :: </p><pre>c. Else,
i. Let captureStart be captureI.[[StartIndex]].
ii. Let captureEnd be captureI.[[EndIndex]].
iii. If fullUnicode is true, then
1. Set captureStart to GetStringIndex(S, captureStart).
2. Set captureEnd to GetStringIndex(S, captureEnd).
iv. Let capture be the Match Record { [[StartIndex]]: captureStart, [[EndIndex]]: captureEnd }.
v. Let capturedValue be GetMatchString(S, capture).
33. For each integer i such that 1 ≤ i ≤ n, in ascending order, do
a. Let captureI be ith element of r&#x27;s captures List.
d. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(i)), capturedValue).
e. If the ith capture of R was defined with a GroupName, then
i. Let s be the CapturingGroupName of that GroupName.
ii. Perform ! CreateDataPropertyOrThrow(groups, s, capturedValue).
iii. Append s to groupNames.
f. Else,
i. Append undefined to groupNames.
c. Else,
i. Let captureStart be captureI.[[StartIndex]].
ii. Let captureEnd be captureI.[[EndIndex]].
iii. If fullUnicode is true, then
1. Set captureStart to GetStringIndex(S, captureStart).
2. Set captureEnd to GetStringIndex(S, captureEnd).
iv. Let capture be the Match Record { [[StartIndex]]: captureStart, [[EndIndex]]: captureEnd }.
vi. Append capture to indices.
33. For each integer i such that 1 ≤ i ≤ n, in ascending order, do
a. Let captureI be ith element of r&#x27;s captures List.
1. Let length be the length of S.
2. Let lastIndex be ℝ(? ToLength(? Get(R, &quot;lastIndex&quot;))).
3. Let flags be R.[[OriginalFlags]].
4. If flags contains &quot;g&quot;, let global be true; else let global be false.
5. If flags contains &quot;y&quot;, let sticky be true; else let sticky be false.
6. If flags contains &quot;d&quot;, let hasIndices be true; else let hasIndices be false.
7. If global is false and sticky is false, set lastIndex to 0.
8. Let matcher be R.[[RegExpMatcher]].
9. If flags contains &quot;u&quot;, let fullUnicode be true; else let fullUnicode be false.
10. Let matchSucceeded be false.
11. If fullUnicode is true, let input be StringToCodePoints(S). Otherwise, let input be a List whose elements are the code units that are the elements of S.
12. NOTE: Each element of input is considered to be a character.
13. Repeat, while matchSucceeded is false,
a. If lastIndex &gt; length, then
i. If global is true or sticky is true, then
1. Perform ? Set(R, &quot;lastIndex&quot;, +0𝔽, true).
ii. Return null.
b. Let inputIndex be the index into input of the character that was obtained from element lastIndex of S.
c. Let r be matcher(input, inputIndex).
d. If r is failure, then
i. If sticky is true, then
1. Perform ? Set(R, &quot;lastIndex&quot;, +0𝔽, true).
2. Return null.
ii. Set lastIndex to AdvanceStringIndex(S, lastIndex, fullUnicode).
e. Else
i. Assert: r is a MatchState.
ii. Set matchSucceeded to true.
14. Let e be r.[[EndIndex]].
15. If fullUnicode is true, set e to GetStringIndex(S, e).
16. If global is true or sticky is true, then
a. Perform ? Set(R, &quot;lastIndex&quot;, 𝔽(e), true).
17. Let n be the number of elements in r.[[Captures]].
18. Assert: n = R.[[RegExpRecord]].[[CapturingGroupsCount]].
19. Assert: n &lt; 2^32 - 1.
20. Let A be ! ArrayCreate(n + 1).
22. Perform ! CreateDataPropertyOrThrow(A, &quot;index&quot;, 𝔽(lastIndex)).
23. Perform ! CreateDataPropertyOrThrow(A, &quot;input&quot;, S).
24. Let match be the Match Record { [[StartIndex]]: lastIndex, [[EndIndex]]: e }.
28. Let matchedSubstr be GetMatchString(S, match).
29. Perform ! CreateDataPropertyOrThrow(A, &quot;0&quot;, matchedSubstr).
21. Assert: The mathematical value of A&#x27;s &quot;length&quot; property is n + 1.
30. If R contains any GroupName, then
31. Else,
a. Let groups be undefined.
27. Append match to indices.
34. a. Let indicesArray be MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups).
</pre></div></p><p><h3>IN ECMAScript</h3>: <div class='case'><p> :: </p><pre>1. Let length be the length of S.
2. Let lastIndex be ℝ(? ToLength(? Get(R, &quot;lastIndex&quot;))).
3. Let flags be R.[[OriginalFlags]].
4. If flags contains &quot;g&quot;, let global be true; else let global be false.
5. If flags contains &quot;y&quot;, let sticky be true; else let sticky be false.
6. If flags contains &quot;d&quot;, let hasIndices be true; else let hasIndices be false.
7. If global is false and sticky is false, set lastIndex to 0.
8. Let matcher be R.[[RegExpMatcher]].
9. If flags contains &quot;u&quot;, let fullUnicode be true; else let fullUnicode be false.
10. Let matchSucceeded be false.
11. If fullUnicode is true, let input be StringToCodePoints(S). Otherwise, let input be a List whose elements are the code units that are the elements of S.
12. NOTE: Each element of input is considered to be a character.
13.Repeat, whilematchSucceededisfalse,
a.IflastIndex&gt;length, then
i.Ifglobalistrueorstickyistrue, then
1. Perform ? Set(R, &quot;lastIndex&quot;, +0𝔽, true).
ii. Return null.
b. Let inputIndex be the index into input of the character that was obtained from element lastIndex of S.
c. Let r be matcher(input, inputIndex).
d.Ifrisfailure, then
i.Ifstickyistrue, then
1. Perform ? Set(R, &quot;lastIndex&quot;, +0𝔽, true).
2. Return null.
ii. Set lastIndex to AdvanceStringIndex(S, lastIndex, fullUnicode).
e.Else,
i. Assert: r is a MatchState.
ii. Set matchSucceeded to true.
14. Let e be r&#x27;s endIndex value.
15. If fullUnicode is true, set e to GetStringIndex(S, e).
16.Ifglobalistrueorstickyistrue, then
a. Perform ? Set(R, &quot;lastIndex&quot;, 𝔽(e), true).
17. Let n be the number of elements in r&#x27;s captures List.
18. Assert: n = R.[[RegExpRecord]].[[CapturingGroupsCount]].
19. Assert: n &lt; 2^32 - 1.
20. Let A be ! ArrayCreate(n + 1).
21. Assert: The mathematical value of A&#x27;s &quot;length&quot; property is n + 1.
22. Perform ! CreateDataPropertyOrThrow(A, &quot;index&quot;, 𝔽(lastIndex)).
23. Perform ! CreateDataPropertyOrThrow(A, &quot;input&quot;, S).
24. Let match be the Match Record { [[StartIndex]]: lastIndex, [[EndIndex]]: e }.
25. Let indices be a new empty List.
26. Let groupNames be a new empty List.
27. Append match to indices.
28. Let matchedSubstr be GetMatchString(S, match).
29. Perform ! CreateDataPropertyOrThrow(A, &quot;0&quot;, matchedSubstr).
30.IfRcontains anyGroupName, then
a. Let groups be OrdinaryObjectCreate(null).
b. Let hasGroups be true.
31.Else,
a. Let groups be undefined.
b. Let hasGroups be false.
32. Perform ! CreateDataPropertyOrThrow(A, &quot;groups&quot;, groups).
33.For eachintegerisuch that 1 ≤i≤n, in ascending order, do
a. Let captureI be i^th element of r&#x27;s captures List.
b.IfcaptureIisundefined, then
i. Let capturedValue be undefined.
ii. Append undefined to indices.
c.Else,
i. Let captureStart be captureI&#x27;s startIndex.
ii. Let captureEnd be captureI&#x27;s endIndex.
iii.IffullUnicodeistrue, then
1. Set captureStart to GetStringIndex(S, captureStart).
2. Set captureEnd to GetStringIndex(S, captureEnd).
iv. Let capture be the Match Record { [[StartIndex]]: captureStart, [[EndIndex]]: captureEnd }.
v. Let capturedValue be GetMatchString(S, capture).
vi. Append capture to indices.
d. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(i)), capturedValue).
e.If theithcapture ofRwas defined with aGroupName, then
i. Let s be the CapturingGroupName of that GroupName.
ii. Perform ! CreateDataPropertyOrThrow(groups, s, capturedValue).
iii. Append s to groupNames.
f.Else,
i. Append undefined to groupNames.
34.IfhasIndicesistrue, then
a. Let indicesArray be MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups).
b. Perform ! CreateDataPropertyOrThrow(A, &quot;indices&quot;, indicesArray).
35. Return A.
</pre></div></p></div><b>line-diffs</b> : --- 
<br>+++ 
<br>@@ -1,30 +1,3 @@
<br>-c.Else,<br>-i.LetcaptureStartbecaptureI.[[StartIndex]].<br>-ii.LetcaptureEndbecaptureI.[[EndIndex]].<br>-iii.IffullUnicodeistrue,then<br>-1.SetcaptureStarttoGetStringIndex(S,captureStart).<br>-2.SetcaptureEndtoGetStringIndex(S,captureEnd).<br>-iv.LetcapturebetheMatchRecord{[[StartIndex]]:captureStart,[[EndIndex]]:captureEnd}.<br>-v.LetcapturedValuebeGetMatchString(S,capture).<br>-33.Foreachintegerisuchthat1≤i≤n,inascendingorder,do<br>-a.LetcaptureIbeithelementofr'scapturesList.<br>-d.Perform!CreateDataPropertyOrThrow(A,!ToString(𝔽(i)),capturedValue).<br>-e.IftheithcaptureofRwasdefinedwithaGroupName,then<br>-i.LetsbetheCapturingGroupNameofthatGroupName.<br>-ii.Perform!CreateDataPropertyOrThrow(groups,s,capturedValue).<br>-iii.AppendstogroupNames.<br>-f.Else,<br>-i.AppendundefinedtogroupNames.<br>-c.Else,<br>-i.LetcaptureStartbecaptureI.[[StartIndex]].<br>-ii.LetcaptureEndbecaptureI.[[EndIndex]].<br>-iii.IffullUnicodeistrue,then<br>-1.SetcaptureStarttoGetStringIndex(S,captureStart).<br>-2.SetcaptureEndtoGetStringIndex(S,captureEnd).<br>-iv.LetcapturebetheMatchRecord{[[StartIndex]]:captureStart,[[EndIndex]]:captureEnd}.<br>-vi.Appendcapturetoindices.<br>-33.Foreachintegerisuchthat1≤i≤n,inascendingorder,do<br>-a.LetcaptureIbeithelementofr'scapturesList.<br> 1.LetlengthbethelengthofS.<br> 2.LetlastIndexbeℝ(?ToLength(?Get(R,"lastIndex"))).<br> 3.LetflagsbeR.[[OriginalFlags]].<br>@@ -49,25 +22,55 @@
<br> 1.Perform?Set(R,"lastIndex",+0𝔽,true).<br> 2.Returnnull.<br> ii.SetlastIndextoAdvanceStringIndex(S,lastIndex,fullUnicode).<br>-e.Else<br>+e.Else,<br> i.Assert:risaMatchState.<br> ii.SetmatchSucceededtotrue.<br>-14.Leteber.[[EndIndex]].<br>+14.Leteber'sendIndexvalue.<br> 15.IffullUnicodeistrue,setetoGetStringIndex(S,e).<br> 16.Ifglobalistrueorstickyistrue,then<br> a.Perform?Set(R,"lastIndex",𝔽(e),true).<br>-17.Letnbethenumberofelementsinr.[[Captures]].<br>+17.Letnbethenumberofelementsinr'scapturesList.<br> 18.Assert:n=R.[[RegExpRecord]].[[CapturingGroupsCount]].<br> 19.Assert:n<2^32-1.<br> 20.LetAbe!ArrayCreate(n+1).<br>+21.Assert:ThemathematicalvalueofA's"length"propertyisn+1.<br> 22.Perform!CreateDataPropertyOrThrow(A,"index",𝔽(lastIndex)).<br> 23.Perform!CreateDataPropertyOrThrow(A,"input",S).<br> 24.LetmatchbetheMatchRecord{[[StartIndex]]:lastIndex,[[EndIndex]]:e}.<br>+25.LetindicesbeanewemptyList.<br>+26.LetgroupNamesbeanewemptyList.<br>+27.Appendmatchtoindices.<br> 28.LetmatchedSubstrbeGetMatchString(S,match).<br> 29.Perform!CreateDataPropertyOrThrow(A,"0",matchedSubstr).<br>-21.Assert:ThemathematicalvalueofA's"length"propertyisn+1.<br> 30.IfRcontainsanyGroupName,then<br>+a.LetgroupsbeOrdinaryObjectCreate(null).<br>+b.LethasGroupsbetrue.<br> 31.Else,<br> a.Letgroupsbeundefined.<br>-27.Appendmatchtoindices.<br>-34.a.LetindicesArraybeMakeMatchIndicesIndexPairArray(S,indices,groupNames,hasGroups).<br>+b.LethasGroupsbefalse.<br>+32.Perform!CreateDataPropertyOrThrow(A,"groups",groups).<br>+33.Foreachintegerisuchthat1≤i≤n,inascendingorder,do<br>+a.LetcaptureIbei^thelementofr'scapturesList.<br>+b.IfcaptureIisundefined,then<br>+i.LetcapturedValuebeundefined.<br>+ii.Appendundefinedtoindices.<br>+c.Else,<br>+i.LetcaptureStartbecaptureI'sstartIndex.<br>+ii.LetcaptureEndbecaptureI'sendIndex.<br>+iii.IffullUnicodeistrue,then<br>+1.SetcaptureStarttoGetStringIndex(S,captureStart).<br>+2.SetcaptureEndtoGetStringIndex(S,captureEnd).<br>+iv.LetcapturebetheMatchRecord{[[StartIndex]]:captureStart,[[EndIndex]]:captureEnd}.<br>+v.LetcapturedValuebeGetMatchString(S,capture).<br>+vi.Appendcapturetoindices.<br>+d.Perform!CreateDataPropertyOrThrow(A,!ToString(𝔽(i)),capturedValue).<br>+e.IftheithcaptureofRwasdefinedwithaGroupName,then<br>+i.LetsbetheCapturingGroupNameofthatGroupName.<br>+ii.Perform!CreateDataPropertyOrThrow(groups,s,capturedValue).<br>+iii.AppendstogroupNames.<br>+f.Else,<br>+i.AppendundefinedtogroupNames.<br>+34.IfhasIndicesistrue,then<br>+a.LetindicesArraybeMakeMatchIndicesIndexPairArray(S,indices,groupNames,hasGroups).<br>+b.Perform!CreateDataPropertyOrThrow(A,"indices",indicesArray).<br>+35.ReturnA.<br><br><div class='error'><p><h3>Section:</h3> <div class='section'><h3>22.2.6.9 RegExp.prototype [ @@matchAll ] ( string ), <a download href='file:///home/martin/regex_coq/warblre/mechanization/spec/Frontend.v'><b>Frontend.v</b>: 783 - 809</a></h3><p>This method performs the following steps when called: </p></div></p><p><h3>IN COQ:</h3> <div class='case'><p> :: </p><pre>5. Let flags be ? ToString(? Get(R, &quot;flags&quot;)).
9. If flags contains &quot;g&quot;, let global be true.
11. If flags contains &quot;u&quot;, let fullUnicode be true.
13. Return CreateRegExpStringIterator(matcher, S, global, fullUnicode).
b. iii. If ? ToString(flags) does not contain &quot;g&quot;, throw a TypeError exception.
5. Return ? Invoke(rx, @@matchAll, « S »).
</pre></div></p><p><h3>IN ECMAScript</h3>: <div class='case'><p> :: </p><pre>1. Let R be the this value.
2. If R is not an Object, throw a TypeError exception.
3. Let S be ? ToString(string).
4. Let C be ? SpeciesConstructor(R, %RegExp%).
5. Let flags be ? ToString(? Get(R, &quot;flags&quot;)).
6. Let matcher be ? Construct(C, « R, flags »).
7. Let lastIndex be ? ToLength(? Get(R, &quot;lastIndex&quot;)).
8. Perform ? Set(matcher, &quot;lastIndex&quot;, lastIndex, true).
9. If flags contains &quot;g&quot;, let global be true.
10. Else, let global be false.
11. If flags contains &quot;u&quot;, let fullUnicode be true.
12. Else, let fullUnicode be false.
13. Return CreateRegExpStringIterator(matcher, S, global, fullUnicode).
</pre></div></p></div><b>line-diffs</b> : --- 
<br>+++ 
<br>@@ -1,6 +1,13 @@
<br>+1.LetRbethethisvalue.<br>+2.IfRisnotanObject,throwaTypeErrorexception.<br>+3.LetSbe?ToString(string).<br>+4.LetCbe?SpeciesConstructor(R,%RegExp%).<br> 5.Letflagsbe?ToString(?Get(R,"flags")).<br>+6.Letmatcherbe?Construct(C,«R,flags»).<br>+7.LetlastIndexbe?ToLength(?Get(R,"lastIndex")).<br>+8.Perform?Set(matcher,"lastIndex",lastIndex,true).<br> 9.Ifflagscontains"g",letglobalbetrue.<br>+10.Else,letglobalbefalse.<br> 11.Ifflagscontains"u",letfullUnicodebetrue.<br>+12.Else,letfullUnicodebefalse.<br> 13.ReturnCreateRegExpStringIterator(matcher,S,global,fullUnicode).<br>-b.iii.If?ToString(flags)doesnotcontain"g",throwaTypeErrorexception.<br>-5.Return?Invoke(rx,@@matchAll,«S»).

            
        </body>
        </html>
        